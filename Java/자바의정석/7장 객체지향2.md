### 7-1~2

```java
public class Study {
    public static void main(String[] args) {
        SutdaDeck deck = new SutdaDeck();
        System.out.println(deck.pick(0));
        System.out.println(deck.pick());
        deck.shuffle();
        for (int i = 0; i < deck.cards.length; i++)
            System.out.print(deck.cards[i] + ",");
        System.out.println();
        System.out.println(deck.pick(0));
    }

}

class SutdaDeck {
    final int CARD_NUM = 20;
    SutdaCard[] cards = new SutdaCard[CARD_NUM];

    SutdaDeck() {
        for (int i = 0; i < CARD_NUM; i++) {
            if (i > 9) {
                cards[i] = new SutdaCard(i - 9, false);
            } else {
                if (i + 1 == 1 || i + 1 == 3 || i + 1 == 8) {
                    cards[i] = new SutdaCard(i + 1, true);
                } else {
                    cards[i] = new SutdaCard(i + 1, false);
                }
            }

        }
    }

    void shuffle() {
        SutdaCard tmp = new SutdaCard();
        int randomIndex = 0;
        for (int i = 0; i < CARD_NUM; i++) {
            randomIndex = (int) (Math.random() * 20);
            tmp = cards[i];
            cards[i] = cards[randomIndex];
            cards[randomIndex] = tmp;
        }
    }

    SutdaCard pick(int index) {
        return cards[index];
    }

    SutdaCard pick() {
        return cards[(int) ((Math.random() * 20) + 1)];
    }
}

class SutdaCard {
    int num;
    boolean isKwang;

    SutdaCard() {
        this(1, true);
    }

    SutdaCard(int num, boolean isKwang) {
        this.num = num;
        this.isKwang = isKwang;
    }

    // info()대신 Object클래스의 toString()을 오버라이딩했다.
    public String toString() {
        return num + (isKwang ? "K" : "");
    }
}
```

### 7-3

오버라이딩 정의 : 상속받은 부모클래스의 메소드를 내용만 수정하는 것

(리턴 타입, 메소드 이름, 매개변수 전부 동일해야함)



필요성: 부모클래스의 메소드는 수정하지 않으면서 (원본 보존) 자식 클래스에서 본인 입맛에 맞게 수정할 수 있음.(편의성?)

### 7-4

c,d



접근제어자는 상속에서 피라미드 모형 생각하면됨

자식클래스에서 접근 범위 넓어지는거 가능



예외는 역 피라미드 모형 생각하셈

자식클래스는 부모클래스보다 예외범위가 적어지는 거 가능